# 설계 원리

- 어떻게 실현할 것인가를 구체적으로 결정하는 활동
- 시스템의 논리 구성을 결정
- 설계 단계의 중심은 요구를 실현하는 솔루션
- 아키텍처 - 소프트웨어 설계에서 특히 중요하며 스프트웨어의 기본 구조를 나타냄. 시스템 성능, 보안, 가용성 등의 품질이 아키텍처를 어떻게 구성하였느냐에 달려있음
- 설계작업
  - 기본 구조 설계 - 아키텍처 설계로 각 모듈의 역할과 인터페이스를 정의
  - 상세 설계 - 모듈 내부의 알고리즘, 데이터를 명세화

## 설계 기본 개념

- 설계는 프로그램이라는 구체적인 대상을 다루지만, 개념적인 작업 -> 설계 작업에 기초가 되는 개념을 정확히 이해하고 적용할 수 있어야 함
- 전통적인 설계 방법인 분할 정복, 추상화, 합성 등의 원리를 적용하여 대규모 문제를 다루었지만 최근에는 아키텍처 기반의 설계 방법으로 바뀜 -> 아키텍처를 고려한 설계가 되어야 복잡한 문제를 다룰 수 있고 변경에 잘 대처할 수 있기 때문

### 서브시스템, 모듈

- 아키텍처 - 시스템을 구성하는 컴포넌트와 컴포넌트 상호작용의 집합
- 컴포넌트 - 독립적으로 취급될 수 있는 단위로 서브시스템 또는 모듈이라고 부름. 대부분의 컴포넌트들은 재사용 가능하도록 설계됨. 반면 특정한 목적, 예를 들면 특정 시스템의 사용자 인터페이스를 제공하는 기능 등을 수행하는 경우도 있음. 프레임워크는 컴포넌트의 한 종류
- 모듈 - 프로그래밍 언어의 문법 구조에서 정의된 컴포넌트. Ex) 메소드, 클래스, 패키지는 Java 프로그램의 모듈임. C언어에서의 모듈은 파일과 함수
- 서브시스템 - 클래스의 모임, 즉 패키지이며 다른 서브시스템과 상호작용하기 위하여 정의된 인터페이스를 가짐. 시스템은 정의 가능한 책임과 목적들을 가지고 있고 소프트웨어나 하드웨어로 구성된 논리적 개체
- 설계는 각 서브시스템이 제공하는 서비스의 명세와 작동되는 제약 조건을 제공

### 설계 관점

1. 모듈 관점 - 일정한 책임을 구현한 코드 단위인 모듈과 그 관계로 소프트웨어 구조를 설명하는 관점 / 분할, 사용관계, 계층 구조, 데이터 모델
2. 컴포넌트 관점 - 실행될 때 동작하는 요소와 상호작용으로 구조를 설명하는 관점 / 클라이언트-서버, 파이프필터, 출판 구독, 이벤트 중심, 리파지토리
3. 할당 관점 - 소프트웨어의 하드웨어 설치, 작업 할당, 구현, 데이터 저장 등에 대한 관점 - 배치 / 설계 / 작업 할당 / 구현 / 데이터 저장

### 설계 작업 과정

1. 설계 목표 설정 - 전체 시스템에 대한설계 목표를 파악하고 결정. 예를 들어 전화 교환 시스템을 개발한다면 고장에 대한 내성, 안전과 보안, 최대 성능이 설계 목표가  될 수 있음
2. 스타일 결정 - 시스템이나 서브시스템의 타입을 결정하기 위하여 설계 목표와 유형에 맞은 아키텍처 스타일을 선택. 적용할 수 있는 아키텍처 스타일이 있다면 이를 적용하여 시스템의 표준 아키텍처를 설계. 없다면 맞춤형 아키텍처를 설계
3. 서브시스템의 기능, 인터페이스 명세 - 서브시스템 사이의 인터페이스를 정의하고 서브시스템 사이의 상호작용을 위한 동작을 작성
4. 아키텍처 설계 검토 - 설계한 아키텍처가 요구, 설계 목표, 설계 원리를 잘 만족하는지 검토

## 품질 목표

- 비기능 요구 사항 - 품질 특성이며 시스템 설계안을 결정하는 요소들
- 아키텍처는 설계에 대한 여러 관점을 명시적으로 언급하여야 함
- 개발자는 기능적인 요구를 이해하고 동시에 기능들이 비기능적인 요구, 즉 품질 목표를 만족하도록 플랫폼을 만들어야 함
- 품질 요구 사항을 충족시키도록 설계할 때 다른 속성에 미치는 영향을 고려하여 설계하여야 함
- 설계작업은 품질 속성의 우선순위를 정하고 절충하는 일이 중요

## 전통적인 설계 원리

- 효율성과 단순성을 중요하게 생각

### 추상화

- 컴포넌트 구현에 대한 자세한 사항을 염려하지 않고 추상적인 수준으로 컴포넌트를 다루는 도구
- 컴포넌트나 시스템은 외부에 서비스를 제공
- 컴포넌트의 추상 - 컴포넌트가 어떻게 동작하는지 내부의 상세한 사항에 구애받지 않고 외부에 보이는 동작을 나타내는 것
- 추상화 - 대상에 대하여 특정한 목적에 관련된 정보에 집중하고 나머지 정보는 무시하는 관점
- 소프트웨어를 데이터나 절차적인 동작 관점으로 정의할 수 있음 Ex) 클라이언트와 서버의 정보교환을 주고받는 메시지 데이터의 구조적인 정보만으로 추상화할 수 있음
- 복잡성을 줄이고 복잡한 소프트웨어 시스템을 효율적으로 다루고 구현할 수 있게 함
- 설계 작업 과정에 필수적인 요소이며 문제 분할의 근본이 됨                                                                                                                                                                                                                           

### 캡슐화

- 추상화된 대상이 제공하는 서비스를 쉽게 접근하게 하는 개념, 서비스를 수행하는 핵심만을 노출시키고 어떻게 서비스를 수행하는 핵심만을 노출시키고 어떻게 서비스를 제공하는지 자세한 것을 숨김
- 은닉 - 캡슐화를 하게 되면 내부에 데이터를 어떻게 저장하는지, 그 데이터를 어떻게 처리하는지, 또는 특정 기능을 어떻게 제공하는지에 대한 내용을 드러내지 않음
- 객체지향 언어가 아니더라도 설꼐에서 따를 수 있는 원리이므로 전통적 설계 원리

### 모듈화

- 문제를 소프트웨어의 구성요소가 될 만한 수준으로 분할하는 과정
- 복잡한 시스템을 세분화 된 구성 요소로 정의하면 개발자와 고객이 더 쉽게 이해할 수 있고 다루기 쉬운 구조가 됨
- 각각의 모듈을 별개로 만들고 수정할 수 있기 때문에 좋은 구조가 됨
- 모듈을 별도로 컴파일할 수 있다면 모듈을 수정해도 전체 시스템을 다시 컴파일 할 필요가 없음
- 시스템의 일부를 변경하였을 때 다른 부분에 영향을 적게 줌
- 너무 많은 모듈로 분할된다면 서로 어떻게 상호작용하는지 이해하기가 어려움

### 결합

- 모듈간에 서로 의존하는 정도
- 좋은 소프트웨어는 낮은 결합력을 가짐. 결합이 강하면 이해하기 어렵고 변경할 때 파급 효과가 큼
- 모듈 간의 결합 정도는 다음 두 가지 요소에 의해 결정
  - 모듈 간 인터페이스 수
  - 각 인터페이스의 복잡성(통신 유형에 따라 결정됨)
- 모듈 사이의 결합
  - 내용 결합 - 한 모듈이 다른 모듈의 내용을 직접 참조하는 경우 발생. P라는 모듈이 Q라는 모듈의 문장을 조작하는 경우 내용 결합에 해당
  - 공통 결합 - 한 모듈이 다른 모듈이 읽은 전역 변수 값을 쓰거나 변경한 경우 발생. 모듈이 매개변수 대신에 전역 변수를 이용하여 데이터를 교환하는 경우 모두 공통 결합
  - 제어 결합 - 한 모듈이 다른 모듈의 제어흐름 경로를 결정하는 경우 제어 결합이 발생
  - 스탬프 결합 - 복합 데이터 구조의 일부만 사용하는 모듈에 복합 데이터 구조 전달할 때 발생. Ex) 세 개의 필드가 있는 레코드를 처음 두 개의 필드만 필요한 모듈에 매개변수로 전달하는 경우 스탬프 결합이다.
  - 데이터 결합 - 모듈들이 주고받는 매개변수가 간단한 타입이거나 레코드 안의 필드이더라도 단순 타입인 경우에 해당

### 응집

- 하나의 모듈 안에서 수행되는 작업들이 서로 관련된 정도, 설계 단위들이 특정 작업을 수행하기 위해 함께 잘 모여 있는지를 나타냄
- 모듈 안의 여러 요소들이 하나의 목적을 위하여 유기적으로 관련되어 있는 것이 제일 좋음
- 높은 응집을 보이는 모듈은 재사용하기도 쉽고 이해하기도 좋으며 무엇보다 중요한 것은 수정하여 받는 영향이 적어짐
- 응집 종류
  - 우연적 응집 - 가장 응집이 약한 형태로 단위 안의 요소들이 의미적으로 아무 관계가 없음
  - 논리적 응집 - 본질적으로 다르더라도 같은 범주의 기능을 수행하므로 논리적으로 분류되기 때문에 그룹으로 묶인 경우
  - 시간적 응집 - 모듈의 내부 요소가 프로그램 실행의 특정한 시간에 처리되므로 한 그룹 안에 모여 있는 경우
  - 절차적 응집 - 모듈 안에서 수행되는 연산이 프로그램에서 수행되는 순서와 관련이 있다면 절차적 응집
  - 교환적 응집 - 모듈의 내부 요소들이 동일한 데이터를 조작하기 때문에 그룹화 된 경우. Ex) 동일한 레코드에 대하여 작동하는 오퍼레이션들이 하나의 모듈 안에 모아진 경우
  - 기능적 응집 - 모듈 내부 요소들이 모듈에 대하여 정의된 하나의 기능에 모두 기여하고 밀접하게 관련되기 때문에 그룹화된 응집. Ex) XML문자열의 어휘 분석이라는 모듈의 기능에 꼭 필요한 요소들만 모여 있다면 기능적 응집
  - 정보적 응집 - 정보적 응집은 여러 가지 오퍼레이션을 수행하지만 각 오퍼레이션은 각각 고유한 시작점과 독립된 코드가 있고 모든 오퍼레이션이 같은 데이터에 대해 실행되는 응집

## 객체지향 설계 원리

